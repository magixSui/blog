<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据库 | MAGIX</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.b119fe2f.css" as="style"><link rel="preload" href="/blog/assets/js/app.7de9164d.js" as="script"><link rel="preload" href="/blog/assets/js/50.9cde37c5.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.f9661e3f.js"><link rel="prefetch" href="/blog/assets/js/11.84ed3257.js"><link rel="prefetch" href="/blog/assets/js/12.0b332606.js"><link rel="prefetch" href="/blog/assets/js/13.f1123190.js"><link rel="prefetch" href="/blog/assets/js/14.4cb76a67.js"><link rel="prefetch" href="/blog/assets/js/15.ce33b901.js"><link rel="prefetch" href="/blog/assets/js/16.73000ac7.js"><link rel="prefetch" href="/blog/assets/js/17.db6e6f95.js"><link rel="prefetch" href="/blog/assets/js/18.bfb481e8.js"><link rel="prefetch" href="/blog/assets/js/19.4d9ba12c.js"><link rel="prefetch" href="/blog/assets/js/2.42716945.js"><link rel="prefetch" href="/blog/assets/js/20.aca3f94f.js"><link rel="prefetch" href="/blog/assets/js/21.1a5609f6.js"><link rel="prefetch" href="/blog/assets/js/22.2ebf2696.js"><link rel="prefetch" href="/blog/assets/js/23.c30dd29b.js"><link rel="prefetch" href="/blog/assets/js/24.937cb4a3.js"><link rel="prefetch" href="/blog/assets/js/25.2f5d5675.js"><link rel="prefetch" href="/blog/assets/js/26.92dc07a0.js"><link rel="prefetch" href="/blog/assets/js/27.f6cc4f9c.js"><link rel="prefetch" href="/blog/assets/js/28.32606a28.js"><link rel="prefetch" href="/blog/assets/js/29.e403cf92.js"><link rel="prefetch" href="/blog/assets/js/3.9357aacf.js"><link rel="prefetch" href="/blog/assets/js/30.475d60c5.js"><link rel="prefetch" href="/blog/assets/js/31.a8329d38.js"><link rel="prefetch" href="/blog/assets/js/32.2d6653bb.js"><link rel="prefetch" href="/blog/assets/js/33.6fea3997.js"><link rel="prefetch" href="/blog/assets/js/34.66a4987d.js"><link rel="prefetch" href="/blog/assets/js/35.2d9d19c3.js"><link rel="prefetch" href="/blog/assets/js/36.a2e0c5dd.js"><link rel="prefetch" href="/blog/assets/js/37.5c973500.js"><link rel="prefetch" href="/blog/assets/js/38.f7bb8781.js"><link rel="prefetch" href="/blog/assets/js/39.6d899459.js"><link rel="prefetch" href="/blog/assets/js/4.58337494.js"><link rel="prefetch" href="/blog/assets/js/40.37141c45.js"><link rel="prefetch" href="/blog/assets/js/41.ff16f98a.js"><link rel="prefetch" href="/blog/assets/js/42.9c134058.js"><link rel="prefetch" href="/blog/assets/js/43.a78ce2e9.js"><link rel="prefetch" href="/blog/assets/js/44.8d679494.js"><link rel="prefetch" href="/blog/assets/js/45.1d4277cd.js"><link rel="prefetch" href="/blog/assets/js/46.6e5a14e5.js"><link rel="prefetch" href="/blog/assets/js/47.9833374a.js"><link rel="prefetch" href="/blog/assets/js/48.88171623.js"><link rel="prefetch" href="/blog/assets/js/49.fb4c5522.js"><link rel="prefetch" href="/blog/assets/js/5.3ac39ba8.js"><link rel="prefetch" href="/blog/assets/js/51.d311fbb4.js"><link rel="prefetch" href="/blog/assets/js/52.0b3d3661.js"><link rel="prefetch" href="/blog/assets/js/53.e6734ee6.js"><link rel="prefetch" href="/blog/assets/js/54.644bc96f.js"><link rel="prefetch" href="/blog/assets/js/55.e49ffc9f.js"><link rel="prefetch" href="/blog/assets/js/56.649a002d.js"><link rel="prefetch" href="/blog/assets/js/57.0a2b68a4.js"><link rel="prefetch" href="/blog/assets/js/58.8e547bb0.js"><link rel="prefetch" href="/blog/assets/js/59.1d20024d.js"><link rel="prefetch" href="/blog/assets/js/6.5f18b713.js"><link rel="prefetch" href="/blog/assets/js/60.d0a15ac1.js"><link rel="prefetch" href="/blog/assets/js/61.e44dc9f3.js"><link rel="prefetch" href="/blog/assets/js/62.cd73b0e4.js"><link rel="prefetch" href="/blog/assets/js/63.23894eac.js"><link rel="prefetch" href="/blog/assets/js/7.95e09fae.js"><link rel="prefetch" href="/blog/assets/js/8.2801459b.js"><link rel="prefetch" href="/blog/assets/js/9.521d3e71.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b119fe2f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">MAGIX</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/javascript/" class="nav-link">博客</a></div><div class="nav-item"><a href="https://github.com/magicxin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/javascript/" class="nav-link">博客</a></div><div class="nav-item"><a href="https://github.com/magicxin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>nodejs</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>typescript</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>网络协议</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>three.js</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>解决方案</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>linux</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>vue 源码学习</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>系统架构设计师</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/blog/system-architect/operating-system.html" class="sidebar-link">操作系统</a></li><li><a href="/blog/system-architect/database.html" class="active sidebar-link">数据库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/system-architect/database.html#基础概念" class="sidebar-link">基础概念</a></li><li class="sidebar-sub-header"><a href="/blog/system-architect/database.html#关系数据库" class="sidebar-link">关系数据库</a></li><li class="sidebar-sub-header"><a href="/blog/system-architect/database.html#关系数据库设计" class="sidebar-link">关系数据库设计</a></li><li class="sidebar-sub-header"><a href="/blog/system-architect/database.html#数据库数学逻辑计算" class="sidebar-link">数据库数学逻辑计算</a></li><li class="sidebar-sub-header"><a href="/blog/system-architect/database.html#分布式数据库系统" class="sidebar-link">分布式数据库系统</a></li><li class="sidebar-sub-header"><a href="/blog/system-architect/database.html#商业智能" class="sidebar-link">商业智能</a></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端架构</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>android</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>science</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>翻译</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>草稿箱</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="数据库"><a href="#数据库" aria-hidden="true" class="header-anchor">#</a> 数据库</h1> <h2 id="基础概念"><a href="#基础概念" aria-hidden="true" class="header-anchor">#</a> 基础概念</h2> <ul><li><strong>元组</strong>：表中的一行就是一个元组。</li> <li><strong>分量</strong>：元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。</li> <li><strong>码</strong>：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。</li> <li><strong>全码</strong>：如果一个码包含了所有的属性，这个码就是全码。</li> <li><strong>主属性</strong>：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。</li> <li><strong>非主属性</strong>：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。</li> <li><strong>外码</strong>：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。</li> <li><strong>函数依赖</strong>：设R(U)是属性集U上的关系模式。X,Y是U的子集，若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则成X函数确定Y或者Y函数依赖与X，   记作：X→Y。</li> <li><strong>等价</strong>：设有两个命题p和q，如果由p作为条件能使得结论q成立，则称p是q的充分条件；若由q能使p成立则称p是q的必要条件；如果p与q能互推（即无论是由q推出p还是p推出q都成立），则称p是q的充分必要条件，简称充要条件，也称p与q等价。</li></ul> <h2 id="关系数据库"><a href="#关系数据库" aria-hidden="true" class="header-anchor">#</a> 关系数据库</h2> <h3 id="数据库的结构与模式"><a href="#数据库的结构与模式" aria-hidden="true" class="header-anchor">#</a> 数据库的结构与模式</h3> <p>数据库的标准结构是<strong>三级结构模式</strong>。</p> <ul><li>外模式：面向用户与应用程序员的用户级</li> <li>概念模式（模式）：面向建立和维护数据库人员的概念级</li> <li>内模式：面向系统程序员的物理级</li></ul> <img src="/blog/system-architect/three-database.png" alt="three-database"> <p>其中概念模式和内模式只能有一个，而外模式可以有多个。因为我们在存储数据时，<strong>模式</strong>是只能以一种结构存储，例如创建学生表。<strong>内模式</strong>
对应我们存储的路径、存储方式、索引方式，所以只能有一种。而外模式对应的是视图，视图是针对基本表而言的，也可以叫虚表，它是抽象出来的
数据集，可以针对不同的业务生成不同种类的数据集。</p> <h3 id="两级映像"><a href="#两级映像" aria-hidden="true" class="header-anchor">#</a> 两级映像</h3> <ul><li>外模式/模式映象</li> <li>模式/内模式映像</li></ul> <p>一个模式对应多个外模式，每一个外模式对应一个外模式/模式映象，当模式改变时，数据库管理员改变外模式/模式映象而应用程序无需修改，保证
<strong>逻辑独立性</strong>。</p> <p>一个模式对应一个内模式，当内模式改变时，数据库管理员改变模式/内模式映像无需改变模式，应用程序也无需修改，保证<strong>物理独立性</strong>。</p> <h3 id="数据模型"><a href="#数据模型" aria-hidden="true" class="header-anchor">#</a> 数据模型</h3> <p>是数据库结构的基础。数据模型的三要素是<strong>数据结构</strong>、<strong>数据操作</strong>、<strong>数据的约束条件</strong>。常用的数据模型有概念数据模型、基本数据模型
以及面向对象模型。</p> <h3 id="实体-联系-e-r模型"><a href="#实体-联系-e-r模型" aria-hidden="true" class="header-anchor">#</a> 实体-联系 E-R模型</h3> <p>E-R 数据模型的三个基本概念：<strong>实体集、联系集和属性</strong>。在用E-R模型设计数据库时，可以避免两个缺陷：数据冗余和不完整。但是，为了更加合理、科学的设计数据库，又出现了规范化。</p> <h4 id="范式"><a href="#范式" aria-hidden="true" class="header-anchor">#</a> 范式</h4> <p>好的关系型数据库设计应减少数据冗余、消除异常，所以关系型数据库数据库设计要遵循一定的规则，这个规则就是范式。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）
、第三范式（3NF）、巴德斯科范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。一般规范化需要做到满足第三范式。</p> <h5 id="第一范式（1nf）"><a href="#第一范式（1nf）" aria-hidden="true" class="header-anchor">#</a> 第一范式（1NF）</h5> <p><strong>第一范式要满足数据表中每一个属性都是原子性的</strong>，不能是集合、数组等非原子性数据项。简单而言，就是数据不可再分。</p> <h5 id="第二范式（2nf）"><a href="#第二范式（2nf）" aria-hidden="true" class="header-anchor">#</a> 第二范式（2NF）</h5> <p><strong>第二范式要在第一范式基础上满足实体属性完全依赖主键</strong>。旨在消除非主属性对主码的部分函数依赖。</p> <h5 id="第三范式（3nf）"><a href="#第三范式（3nf）" aria-hidden="true" class="header-anchor">#</a> 第三范式（3NF）</h5> <p>在1NF基础上，任何非主属性不依赖于其它非主属性，在2NF基础上消除传递依赖。</p> <h5 id="bc范式（bcnf）"><a href="#bc范式（bcnf）" aria-hidden="true" class="header-anchor">#</a> BC范式（BCNF）</h5> <p>在1NF基础上，任何非主属性不能对主键子集依赖，在3NF基础上消除对主码子集的依赖，即每个表中只有一个候选键。</p> <h5 id="第四范式（4nf）"><a href="#第四范式（4nf）" aria-hidden="true" class="header-anchor">#</a> 第四范式（4NF）</h5> <p>消除表中的多值依赖。</p> <p>因为规则越高表越多，增加了查询复杂度，降低了查询性能。因此通常使用第三范式平衡。</p> <h3 id="事务"><a href="#事务" aria-hidden="true" class="header-anchor">#</a> 事务</h3> <p>事务是一系列对数据库更稳更新操作组成的程序执行逻辑单元。
事务有四个特性，简称 ACID：</p> <ul><li>原子性（Atomicity）</li> <li>一致性（Consistency）</li> <li>隔离性（Isolation）</li> <li>持久性（Duration）</li></ul> <blockquote><p>图片摘自网络</p></blockquote> <img src="/blog/system-architect/transzction.png" alt="transzction"> <h4 id="原子性（atomicity）"><a href="#原子性（atomicity）" aria-hidden="true" class="header-anchor">#</a> 原子性（Atomicity）</h4> <p>原子性，代表着事务的执行必须是一个最小的执行单元，必须满足：</p> <ul><li>全部执行成功</li> <li>全部执行失败</li></ul> <p>事务中的操作全部成功，事务才能执行成功。</p> <h4 id="一致性（consistency）"><a href="#一致性（consistency）" aria-hidden="true" class="header-anchor">#</a> 一致性（Consistency）</h4> <p>一致性可以理解为数据上的守恒。不能因为 A =&gt; B B发生了变化而 A 没有变化。</p> <h4 id="隔离性-（isolation）"><a href="#隔离性-（isolation）" aria-hidden="true" class="header-anchor">#</a> 隔离性 （Isolation）</h4> <p>事务与事务之间各自具有完整的数据空间，相互不影响。</p> <h5 id="隔离性级别"><a href="#隔离性级别" aria-hidden="true" class="header-anchor">#</a> 隔离性级别</h5> <ul><li>读未提及（READ_UNCOMMITTED）</li> <li>读已提交（READ_COMMITTED）</li> <li>可重复读（REPEATABLE_READ）</li> <li>顺序读（SERIALIZABLE）</li></ul> <h4 id="持久性（duration）"><a href="#持久性（duration）" aria-hidden="true" class="header-anchor">#</a> 持久性（Duration）</h4> <p>事务的持久性是指事务一旦提交后，数据库中的数据必须被永久的保存下来。即使服务器系统崩溃或服务器宕机等故障。
只要数据库重新启动，那么一定能够将其恢复到事务成功结束后的状态。</p> <h3 id="并发控制"><a href="#并发控制" aria-hidden="true" class="header-anchor">#</a> 并发控制</h3> <p>事务的并发控制的方式主要是封锁。</p> <ul><li>排他锁 X</li> <li>共享锁 S</li></ul> <h3 id="数据库的备份与恢复"><a href="#数据库的备份与恢复" aria-hidden="true" class="header-anchor">#</a> 数据库的备份与恢复</h3> <p>数据的转储分为<strong>静态转储、动态转储、海量转储和增量转储</strong>。数据库的四类故障是<strong>事务故障、系统故障、介质故障和计算机病毒</strong>。</p> <h4 id="事务故障"><a href="#事务故障" aria-hidden="true" class="header-anchor">#</a> 事务故障</h4> <p>撤销事务（UNDO）、重做事务（UNDO）。</p> <h4 id="介质故障"><a href="#介质故障" aria-hidden="true" class="header-anchor">#</a> 介质故障</h4> <p>需要数据库管理员装入数据库副本和日记文件副本，再由系统进行撤销和重做。</p> <h2 id="关系数据库设计"><a href="#关系数据库设计" aria-hidden="true" class="header-anchor">#</a> 关系数据库设计</h2> <h3 id="数据库设计方法"><a href="#数据库设计方法" aria-hidden="true" class="header-anchor">#</a> 数据库设计方法</h3> <p>数据库设计方法分为四类：<strong>直观设计法、规范设计法、计算机辅助设计法、自动化设计法</strong>。</p> <h3 id="数据库设计流程"><a href="#数据库设计流程" aria-hidden="true" class="header-anchor">#</a> 数据库设计流程</h3> <p>数据库设计分为<strong>需求分析、概念结构分析、逻辑结构设计、物理结构设计、应用程序设计和运行维护 6 个阶段</strong>。</p> <h4 id="需求分析"><a href="#需求分析" aria-hidden="true" class="header-anchor">#</a> 需求分析</h4> <p>对现实世界需要处理的对象及业务进行分析处理，使用数据流图（DFD）生成图像化描述，并使用规范表格进行描述，最后生成需求说明书。</p> <h4 id="概念结构分析"><a href="#概念结构分析" aria-hidden="true" class="header-anchor">#</a> 概念结构分析</h4> <p>概念结构分析也被称作建模，最常用的方式是 E-R 模型设计。</p> <h4 id="逻辑结构设计"><a href="#逻辑结构设计" aria-hidden="true" class="header-anchor">#</a> 逻辑结构设计</h4> <p>逻辑结构设计主要任务是确定数据模型，将 E-R 图转化为制定数据模型，确定完整性约束，确定用户视图。</p> <h4 id="物理结构设计"><a href="#物理结构设计" aria-hidden="true" class="header-anchor">#</a> 物理结构设计</h4> <p>数据库在物理设备上的存储结构及存取方法被称为数据库的物理结构。数据库的物理结构设计是利用 DBMS 提供的方法，以较优的存储结构和存取路径
、合理的数据存放位置及存储分配，设计出高效可实现的数据库的物理结构。</p> <h4 id="数据库应用程序设计"><a href="#数据库应用程序设计" aria-hidden="true" class="header-anchor">#</a> 数据库应用程序设计</h4> <p>数据库应用程序设计是 DBMS 的二次开发。开发人员使用开发语言 （主要是SQL）来进行开发。</p> <h4 id="运行维护"><a href="#运行维护" aria-hidden="true" class="header-anchor">#</a> 运行维护</h4> <p>数据库转储和恢复，安全性完整性控制，性能监督、分析改造，数据库的重组和重构等。</p> <h3 id="完整性约束"><a href="#完整性约束" aria-hidden="true" class="header-anchor">#</a> 完整性约束</h3> <p>存储在数据库中的所有数据值均正确的状态。防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息。</p> <ol><li>实体完整性（实体完整性是对关系中的记录唯一性，也就是主键的约束。准确地说，实体完整性是指关系中的主属性值不能为Null且不能有</li> <li>参照完整性（参照完整性是对关系数据库中建立关联关系的数据表间数据参照引用的约束，也就是对外键的约束。准确地说，参照完整性是指
关系中的外键必须是另一个关系的主键有效值，或者是NULL。参考完整性维护表间数据的有效性,完整性,通常通过建立外部键联系另一表的主键实
现,还可以用触发器来维护参考完整性）</li> <li>用户定义的完整性。</li></ol> <h2 id="数据库数学逻辑计算"><a href="#数据库数学逻辑计算" aria-hidden="true" class="header-anchor">#</a> 数据库数学逻辑计算</h2> <h3 id="闭包"><a href="#闭包" aria-hidden="true" class="header-anchor">#</a> 闭包</h3> <p>设X和Y均为关系R的属性集的子集，F是R上的函数依赖集，若对R的任一属性集B，一旦X→B，必有B⊆Y，且对R的任一满足以上条件的属性集Y1 ，
必有Y⊆Y1，此时称Y为属性集X在函数依赖集F下的闭包，记作x+。</p> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>反复读了几遍之后，觉得定义还是最准确的，最好不要用其他的方式代入理解。</p></div> <p>然后怎么求闭包呢？</p> <div class="language- extra-class"><pre class="language-text"><code>设有关系模式R(U，F)，其中U={A，B，C，D，E，I}，F={A→D，AB→E，BI→E，CD→I，E→C}，计算(AE)+
(1) 令X={AE}，X(0)=AE
(2) 分别寻找 A 、E 的推导。 A→D， E→C；所以 X(1) = X(0)DC = ACDE，X(1)≠X(0)，同时可以标记 A→D， E→C 不可重复用。
(3) 寻找非 A 、E 使用过的推导，并且是 X(1) 的子集。  CD→I；所以 X(2) = X(1)I = ACDEI 函数依赖中已没有 X(2) 的子集，计算结束。
(AE)+ = ACDEI
</code></pre></div><h3 id="候选码"><a href="#候选码" aria-hidden="true" class="header-anchor">#</a> 候选码</h3> <p>对于给定的关系R（A1，A2，…An）和函数依赖集F，可将其属性分为4类：</p> <ul><li>L类  仅出现在函数依赖左部的属性。</li> <li>R 类  仅出现在函数依赖右部的属性。</li> <li>N 类  在函数依赖左右两边均未出现的属性。</li> <li>LR类  在函数依赖左右两边均出现的属性。</li></ul> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <ul><li><strong>定理</strong>：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，则X必为R的任何候选码的成员。</li> <li><strong>推论</strong>：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，且X+包含了R的全部属性；则X必为R的唯一候选码。</li> <li><strong>定理</strong>：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是R类属性，则X不在任何候选码中。</li> <li><strong>定理</strong>：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是N类属性，则X必为R的任何候选码的成员。</li> <li><strong>推论</strong>：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类和N类组成的属性集，且X+包含了R的全部属性；则X是R的唯一候选码。</li></ul></div> <h3 id="候选键"><a href="#候选键" aria-hidden="true" class="header-anchor">#</a> 候选键</h3> <p>可能成为候选键的有 L 类，LR 类和 N 类。</p> <h3 id="最小函数依赖"><a href="#最小函数依赖" aria-hidden="true" class="header-anchor">#</a> 最小函数依赖</h3> <p>如果函数依赖集F满足下列条件，则称F为最小函数依赖集或最小覆盖。</p> <ol><li>F中的任何一个函数依赖的右部仅含有一个属性；</li> <li>F中不存在这样一个函数依赖X→A，使得F与F-{X→A}等价；</li> <li>F中不存在这样一个函数依赖X→A，X有真子集Z使得F-{X→A}∪{Z→A}与F等价。</li></ol> <h4 id="去掉函数依赖步骤"><a href="#去掉函数依赖步骤" aria-hidden="true" class="header-anchor">#</a> 去掉函数依赖步骤</h4> <ol><li>用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；</li> <li>去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，看X+是否包含Y，若是，则去掉X→Y；否则不能去掉，依次做下去。直到找不到冗余的函数依赖；</li> <li>去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。例如XY→A，若要判Y为多余的，则以X→A代替XY→A是否等价？若A属于(X)+，则Y是多余属性，可以去掉。</li></ol> <p>具体操作：若左侧为 AB ，右侧为 CD ，则可分解为 AB→C ， AB→D；去掉其中的一个依赖 AB→C ，然后计算 AB 的闭包 Y，看 Y 是否包含 C，如果包含，AB→C 就是多余依赖；最后判断是否含有左侧依赖。</p> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>业余时间可以了解离散数学，最近篇幅大都与离散数学相关。F-{X→A} 代表两集合相减，属于 F 不属于 {X→A} 的部分。</p></div> <h2 id="分布式数据库系统"><a href="#分布式数据库系统" aria-hidden="true" class="header-anchor">#</a> 分布式数据库系统</h2> <h2 id="商业智能"><a href="#商业智能" aria-hidden="true" class="header-anchor">#</a> 商业智能</h2></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/system-architect/operating-system.html" class="prev">
          操作系统
        </a></span> <span class="next"><a href="/blog/front-design/front-design.html">
          前端架构设计
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/blog/assets/js/app.7de9164d.js" defer></script><script src="/blog/assets/js/50.9cde37c5.js" defer></script>
  </body>
</html>
