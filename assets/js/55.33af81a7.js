(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{221:function(t,n,e){"use strict";e.r(n);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"操作系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作系统","aria-hidden":"true"}},[t._v("#")]),t._v(" 操作系统")]),t._v(" "),e("h2",{attrs:{id:"进程互斥"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程互斥","aria-hidden":"true"}},[t._v("#")]),t._v(" 进程互斥")]),t._v(" "),e("p",[t._v("操作系统中，"),e("strong",[t._v("进程")]),t._v("是资源占有的最小单位，"),e("strong",[t._v("线程")]),t._v("可以访问其所在进程内的所有资源，但线程本身不占有资源或仅占有一点点资源。\n对于某些资源来说，同一时间只能被一个进程占用，这种资源就是"),e("strong",[t._v("临界资源")]),t._v("。如打印机、硬盘内一些变量和数据等。\n对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。\n而进程内访问临界资源的代码被成为"),e("strong",[t._v("临界区")]),t._v("。")])])}],!1,null,null,null);n.default=s.exports}}]);